<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VectSharp: Renderers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="Doxy.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VectSharp
   &#160;<span id="projectnumber">1.6.0</span>
   </div>
   <div id="projectbrief">A light library for C# vector graphics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__vect_sharp_8_three_d__renderers.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Renderers </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A renderer is an instance of a class implementing the <code>IRenderer</code> interface, whose only purpose is essentially to produce a <a class="el" href="namespace_vect_sharp.html">VectSharp</a> <code>Page</code> out of a scene, a set of lights and a camera. Indeed, the <code>IRenderer</code> interface defines only one method:</p>
<ul>
<li><p class="startli"><code>Page Render(IScene scene, IEnumerable&lt;ILightSource&gt; lights, Camera camera);</code></p>
<p class="startli">This method, when overridden in a class implementing this interface, will return a 2D representation (in the form of a <code><a class="el" href="class_vect_sharp_1_1_page.html" title="Represents a Graphics object with a width and height.">VectSharp.Page</a></code> object) of the 3D <code>scene</code> illuminated with the specified <code>lights</code> and viewed through the specified <code>camera</code>. The size of the page will be equal to the <code>Size</code> of the <code>camera</code>.</p>
</li>
</ul>
<p>Each class implementing this interface renders the 3D scene using a different algorithm, and properties on these classes can be used to specify additional parameters for the algorithm. Currently, <a class="el" href="namespace_vect_sharp_1_1_three_d.html">VectSharp.ThreeD</a> contains three <code>IRenderer</code> implementations, each with its advantages and disadvantages:</p>
<ul>
<li>The <code>VectorRenderer</code> renders the scene to a vector graphics object.<ul>
<li>For simple scenes, the performance of this renderer is much better than the others. The results are vector images, thus they can be scaled at any size without loss of detail.</li>
<li>Only one of the rendering steps (sorting the object) is parallelised.</li>
<li>Artifacts can arise relatively often, especially when specular highlights and shadows are activated.</li>
</ul>
</li>
<li>The <code>RasterRenderer</code> produces a raster image using a rasterisation algorithm to draw the triangles in the scene.<ul>
<li>This renderer produces better results with more complex scenes.</li>
<li>Triangles are rendered one at a time, but each triangle is rendered in parallel.</li>
<li>It can have issues with multiple transparent objects one in front of the other and does not support anti-aliasing, which may also cause an annoying "edge" effect when 2D elements (lines and points) are included in the scene.</li>
</ul>
</li>
<li>The <code>RaycastingRenderer</code> produces a raster image using a raycasting algorithm.<ul>
<li>This renderer produces the best-looking images, sometimes at the expense of performance (depending on the number of processors available). Optionally, it supports anti-aliasing.</li>
<li>Each pixel is rendered in parallel.</li>
<li>Performance is best when the computer has many processors available for rendering.</li>
</ul>
</li>
</ul>
<p>Note that none of these renderers uses GPU acceleration (this is both to keep the code simple and to maintain portability), although in principle it should be possible to write a renderer that uses GPU acceleration.</p>
<h1><a class="anchor" id="autotoc_md66"></a>
The &lt;tt&gt;VectorRenderer&lt;/tt&gt; class</h1>
<p>The <code>VectorRenderer</code> class renders the scene as a series of vector graphics objects. Each <code>Point3DElement</code> in the scene is represented by a circle, <code>Line3DElement</code>s by lines, and <code>Triangle3DElement</code>s by triangles in vector coordinates.</p>
<p>This class has a parameterless constructor and the following public properties:</p>
<ul>
<li><p class="startli"><code>double DefaultOverFill { get; set; } = 0</code></p>
<p class="startli">This property determines the default value of the <code>OverFill</code> property for base <code>Triangle3DElement</code>s that do not implement the <code>IVectorRendererTriangle3DElement</code> interface.</p>
</li>
<li><p class="startli"><code>double ResamplingMaxSize { get; set; } = double.NaN</code></p>
<p class="startli">This property determines the maximum size for the resampling step (see below). If this is <code>double.NaN</code>, resampling is disabled.</p>
</li>
<li><p class="startli"><code>ResamplingTimes ResamplingTime { get; set; } = ResamplingTimes.AfterSorting</code></p>
<p class="startli">This property determines when the resampling step happens. The possible values are <code>ResamplingTimes.AfterSorting</code> (the default value), which means that resampling happens after the sorting step (this results in better performance), or <code>ResamplingTimes.BeforeSorting</code>, which means that resampling happens before the sorting step. The <code>ResamplingTimes</code> enum is defined within the <code>VectorRenderer</code> class.</p>
</li>
<li><p class="startli"><code>bool ResampleLines { get; set; } = true</code></p>
<p class="startli">This value determines whether lines are also resampled during the resampling step. The main reason not to resample lines is that this would interfere with line caps and line dash styles.</p>
</li>
</ul>
<p>The rendering algorithm of the <code>VectorRenderer</code> uses the following steps:</p>
<ol type="1">
<li>Convert</li>
<li>Cull</li>
<li>Resample (optional)</li>
<li>Project</li>
<li>Compute shadow list</li>
<li>Compare</li>
<li>Sort</li>
<li>Resample (optional)</li>
<li>Render</li>
</ol>
<h2><a class="anchor" id="autotoc_md67"></a>
1. Converting</h2>
<p>The conversion step iterates through all the elements in the scene, and converts any <code>Triangle3DElement</code> that does not implement the <code>IVectorRendererTriangle3DElement</code> interface into a <code>VectorRendererTriangle3DElement</code> with the same coordinates, normals and materials. This interface defines, in particular, an <code>OverFill</code> property that is used to address some of the artifacts that can arise when using the <code>VectorRenderer</code>. The value of the <code>OverFill</code> property of the new object is determined by the value of the <code>DefaultOverFill</code> property of the renderer.</p>
<h2><a class="anchor" id="autotoc_md68"></a>
2. Culling</h2>
<p>In this step, the <code>Camera</code> is asked whether each of the objects in the scene should be culled or not. Non-culled objects are preserved in a list.</p>
<h2><a class="anchor" id="autotoc_md69"></a>
3. Resampling</h2>
<p>Depending on the value of the <code>ResamplingTime</code> property of the renderer, this step can happen just after the culling or just after the sorting step. This step is also skipped if the <code>ResamplingMaxSize</code> property of the renderer has a value of <code>double.NaN</code>.</p>
<p>In this step, the renderer computes the area (in camera plane units) of 2D projection of each triangle in the camera plane. If this is greater than the <code>ResamplingMaxSize</code> of the renderer, the triangle is split into four triangles of equal area, and this is repeated until the size of the triangles is smaller than <code>ResamplingMaxSize</code>. A similar approach is followed for lines: the square of the length of each line is computed, and if this is greater than the thresold, the line is split in half. The length of each half is then computed and so on. Points are left unchanged.</p>
<p>This step helps solve some of the artifacts due to the nature of the algorithm, but causes a drop in performance (because the number of triangles in the scene increases dramatically). Performing the resampling step after the sorting step can help in reducing artifacts due to specular highlights or shadows, without causing too much of a performance hit. However, artifacts due to intersecting surfaces or circular dependencies can only be solved if the resampling is performed before the sorting step, and this has the potential to cause a massive slowdown due to the huge number of triangles that have to be sorted.</p>
<h2><a class="anchor" id="autotoc_md70"></a>
4. Projecting</h2>
<p>In this step, the coordinates of the 2D projection of the triangles in the camera plane are computed using the <code>SetProjection</code> method of the 3D elements. These projections are stored within the 3D element object and are recalled later using the <code>GetProjection</code> method.</p>
<h2><a class="anchor" id="autotoc_md71"></a>
5. Computing the shadow list</h2>
<p>At this stage, if any of the lights that have been used has its <code>CastsShadow</code> property set to <code>true</code>, the method computes a list of all triangles whose <code>CastsShadow</code> property is also <code>true</code>. Both culled and non-culled triangles are considered and, even if the resampling step has already happened, the original triangles are used instead of their resampled counterparts.</p>
<p>This list of triangles that cast shadows is later used to determine which light sources are not visible from each triangle that receives a shadow.</p>
<h2><a class="anchor" id="autotoc_md72"></a>
6. Comparing</h2>
<p>This is usually the most time-consuming step of this algorithm. Each 3D element is compared with every other 3D element in the scene in order to determine which one lies in front with respect to the current camera. The <code>Compare</code> method of the <code>Camera</code> is used. If the scene contains <img src="https://render.githubusercontent.com/render/math?math=n" alt="" class="inline"/> elements, then <img src="https://render.githubusercontent.com/render/math?math=\frac{n(n - 1)}{2}" alt="" class="inline"/> comparisons have to be performed in this step.</p>
<p>When applied to two objects <code>A</code> and <code>B</code>, the <code>Compare</code> method can return one of three values for each comparison:</p>
<ul>
<li>If the method returns <code>-1</code>, then <code>A</code> is in front of <code>B</code> when viewed with the current camera. In this case, <code>A</code> will be drawn after <code>B</code> during the rendering step.</li>
<li>If the method returns <code>1</code>, then <code>B</code> is in front of <code>A</code> when viewed with the current camera/. In this case, <code>B</code> will be drawn after <code>A</code> during the rendering step.</li>
<li><p class="startli">If the method returns <code>0</code>, then either:</p><ul>
<li>The two objects do not overlap; or</li>
<li>It was not possible to determine univocally which object is in front of the other (e.g. because the two objects intersect)</li>
</ul>
<p class="startli">In this case, which of the two objects will be drawn before the other during the rendering step is undefined and it will be determined during the sorting step based on the context of the other objects in the scene. In most cases, this decision will be either irrelevant (because the two objects do not overlap), or necessarily unsatisfactory (because if the two objects intersect, there is no "right" way to draw one in front of the other).</p>
</li>
</ul>
<p>This step is performed separately from the following step, because, since comparing two objects does not depend on the other objects in the scene, it can be easily parallelised. This uses <code>Parallel.For</code> and thus should automatically use as many processor cores as there are avaiable. The results of the comparisons are stored in an array and used in the following step.</p>
<h2><a class="anchor" id="autotoc_md73"></a>
7. Sorting</h2>
<p>The comparisons that have been performed in the previous step are used to perform a <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological ordering</a> of the elements in the 3D scene. The algorithm used is a variaton of the one described in this <a href="https://www.codeproject.com/Articles/869059/Topological-sorting-in-Csharp">CodeProject article</a>.</p>
<p>In addition to the caveat described above about intersecting elements, this algorithm will also fail to sort the elements properly in the presence of <em>cyclical dependencies</em>, e.g. three objects such that <code>A</code> is in front of <code>B</code>, <code>B</code> is in front of <code>C</code> and <code>C</code> is in front of <code>A</code>: in these case, it is not possible to determine a global ordering that preserves the pairwise relationships. An example of this and of how this can be addressed is provided below.</p>
<h2><a class="anchor" id="autotoc_md74"></a>
8. Resampling</h2>
<p>If the resampling step has not been performed yet, it is performed now. This reduces the impact of resampling because the additional elements do not have to go through the comparison and sorting step, but it also makes it impossible to fix artifacts due to the sorting algorithm in this way.</p>
<h2><a class="anchor" id="autotoc_md75"></a>
9. Rendering</h2>
<p>In this step, the actual rendering takes place. The elements are drawn back-to-front, based on the sorting that has been performed in step 7.</p>
<p>The colours of points and lines are determined trivially by their <code>Colour</code> property. For triangles, instead, a flat shading model is use, i.e. the whole triangle is filled with a single colour. The colour is determined by the <code>GetColour</code> method of the triangle, applied at the triangles centroid. The lights that are visible by the triangle are also determined based on the centroid of the triangle and the list of triangles that cast shadows.</p>
<p>This can cause artifacts when specular highlights are activated, because, based on the position of the centroid, even triangles that are coplanar may reflect a different amount of light towards the camera, thus they will be shaded differently. The same problem also happens in the case of any light source that is not a <code>ParallelLightSource</code> (because the angle of incidence will be different between different triangles, even if they are coplanar). Finally, artifacts will also appear when shadows are activated, because the whole area of a triangle whose centroid lies in the shadow of another triangle will be shadowed.</p>
<p>This step, combined with the previous comparison and sorting steps, are essentially an implementation of the <a href="https://en.wikipedia.org/wiki/Painter%27s_algorithm">Painter's algorithm</a>, with the associated advantages and drawbacks.</p>
<p>The following section shows examples of artifacts that can appear when a <code>VectorRenderer</code> is used and how they can be mitigated.</p>
<h2><a class="anchor" id="autotoc_md76"></a>
Fantastic artifacts and how to avoid them</h2>
<p>The following figure shows three examples of artifacts that happen due to the algorithm of the <code>VectorRenderer</code>. The numbers above each image are the number of milliseconds that were necessary to render the scene on a PC with a 12-core/24-thread AMD Ryzen 9 3900X processor.</p>
<p>&lt;image src="images/VectorRendererArtifacts.svg" style="height: 16em" align="center"&gt;</p>
<p>For reference, here is how the scenes look like when rendered using a <code>RayCastingRenderer</code> (which does not cause the same kind of artifact) at a 1000x1000 pixel resolution each, with 4X bilinear antialiasing.</p>
<p>&lt;image src="images/VectorRendererArtifacts_reference.svg" style="height: 16em" align="center"&gt;</p>
<ul>
<li><p class="startli">The first figure shows a cube illuminated by a <code>ParallelLightSource</code> that casts a shadow on a rectangle. The artifacts here are that:</p><ul>
<li>There is a thin white line between the two triangles that make up each side of the cube and the rectangle. This is due to rounding errors and antialiasing.</li>
<li>The second issue is more subtle: the two triangles that make up each side of the cube and the rectangle, despite being coplanar, have different shadings (due to the specular highlights).</li>
<li>The shadow of the cube entirely covers one of the triangles constituting the floor rectangle.</li>
</ul>
<p class="startli">The first issue can be solved by using an appropriate value for the <code>DefaultOverFill</code> property of the <code>VectorRenderer</code> (or by converting the triangles to <code>VectorRendererTriangle3DElement</code>s and setting their <code>OverFill</code> property). For example, this is how the scene looks with a <code>DefaultOverFill</code> of <code>0.05</code>:</p>
<p class="startli">&lt;image src="images/VectorRendererArtifacts_cubeOverfill.svg" style="height: 16em" align="center"&gt;</p>
<p class="startli">Note that depending on your screen resolution and the program you are using to view the images, you may still notice a bit of a gap. The second issue can be solved by disabling the specular highlights on the cube and the triangle, i.e. by setting the <code>SpecularReflectionCoefficient</code> property of their materials to <code>0</code> (and increasing the <code>DiffuseReflectionCoefficient</code> to compensate):</p>
<p class="startli">&lt;image src="images/VectorRendererArtifacts_cubeOverfillNoSpecular.svg" style="height: 16em" align="center"&gt;</p>
<p class="startli">However, this still does not solve the shadow problem. The best that we can do here is to use <code>ResamplingMaxSize</code> property of the <code>VectorRenderer</code>. Here is how the scene looks with various values of this property (indicated by the orange numbers at the bottom):</p>
<p class="startli">&lt;image src="images/VectorRendererArtifacts_cubeOverfillResampling.svg" style="height: 16em" align="center"&gt;</p>
<p class="startli">Since this approach also solves the specular highlight problem, specular highlights have been re-enabled here. In this case, the <code>ResamplingTime</code> property does not have any effect, as the artifact is not due to the sorting algorithm.</p>
<p class="startli">While this approach produces better results (especially with the smaller values for <code>ResamplingMaxSize</code>), it causes a significant increase in computation time. Furthermore, the computation time that is displayed here does not take into account the time to export the image to a file and the time that the viewer needs to draw the image (both of which are significantly increased); another factor to take into account is that the file size also increases significantly (the previous image was about 2.5MB in size, while the vector image without resampling only weighs about 7kB and the raster reference image is about 184kB).</p>
<p class="startli">Considering that the "jagged" effect visible here cannot really be improved much more than this, even by reducing the threshold to unrealistically low values, the best approach here would be to disable shadows when using the <code>VectorRenderer</code> and to use another renderer if the shadows are really needed.</p>
</li>
<li><p class="startli">The second figure shows two intersecting tetrahedra together with a line that intersects both of them. The artifacts here are that the intersections are mostly wrong, as it is not clear that the two tetrahedra intersect, and the line is overlaid on both of them, instead going through the corner. The only thing that we can do here is again to use the <code>ResamplingMaxSizeProperty</code>; in this case we also need to set the <code>ResamplingTime</code> property to <code>ResamplingTimes.BeforeSorting</code>, because the artifact is due to the sorting algorithm:</p>
<p class="startli">&lt;image src="images/VectorRendererArtifacts_tetrahedraOverfillResampling.svg" style="height: 16em" align="center"&gt;</p>
<p class="startli">This is better; however, some artifacts still persist around the line. The rendering can be improved further by disabling the line resampling (i.e. by setting the <code>ResampleLines</code> property of the <code>VectorRenderer</code> to false) or by removing the line altoghether:</p>
<p class="startli">&lt;image src="images/VectorRendererArtifacts_tetrahedraOverfillResamplingNoLine.svg" style="height: 16em" align="center"&gt;</p>
<p class="startli">However, the scene with the line still shows a bit of an artifact and there really is no way to get definitively rid of that. Also note the great increase in rendering time.</p>
</li>
<li><p class="startli">The third scene shows a "cyclical dependency", i.e. three objects none of which is above all the others. Similarly, we can address this by using the <code>ResampleMaxSize</code> property of the <code>VectorRenderer</code> with a <code>ResamplingTime</code> of <code>ResamplingTimes.BeforeSorting</code>:</p>
<p class="startli">&lt;image src="images/VectorRendererArtifacts_cyclicOverfillResampling.svg" style="height: 16em" align="center"&gt;</p>
<p class="startli">In this case, even a <code>ResamplingMaxSize</code> of <code>100</code> is enough to obtain a good result (discounting the patchwork effect that can be addressed by disabling specular highlights).</p>
</li>
</ul>
<p>These examples show the artifacts that can arise when using the <code>VectorRenderer</code> and how they can be addressed. This can be generalised to obtain the following tips.</p>
<h2><a class="anchor" id="autotoc_md77"></a>
Tips for using the &lt;tt&gt;VectorRenderer&lt;/tt&gt;</h2>
<ul>
<li>Use the <code>DefaultOverFill</code> property of the renderer, or set the <code>OverFill</code> property of the triangles to address the gaps between triangles.</li>
<li>Avoid intersecting elements and cyclic dependencies.</li>
<li>Only use <code>ParallelLightSource</code>s.</li>
<li>Disable specular highlights.</li>
<li>Disable shadows.</li>
<li>Use the <code>ResamplingMaxSize</code> property to solve some issues at the expense of computation time and memory.</li>
<li>When all else fails, manually split problematic elements and/or use the <code>ZIndex</code> property to manually sort them.</li>
</ul>
<h1><a class="anchor" id="autotoc_md78"></a>
The &lt;tt&gt;RasterRenderer&lt;/tt&gt; class</h1>
<p>The <code>RasterRenderer</code> class uses a different algorithm. Once the 2D vector coordinates of the elements are computed, the elements are rasterised in an arbitrary order. A "z-buffer" is used to keep track of the z-depth of the element that was rendered at each pixel.</p>
<p>The constructor for this class requires two <code>int</code> parameters, which represent the width and height (in pixels) of the rendered image. Note that the <code>Page</code> returned by the <code>Render</code> method will always have the same size as the camera's <code>Size</code> property.</p>
<p>This class defines the following public properties:</p>
<ul>
<li><p class="startli"><code>int RenderWidth { get; }</code></p>
<p class="startli">This property returns the width (in pixels) of the rendered image.</p>
</li>
<li><p class="startli"><code>int RenderHeight { get; }</code></p>
<p class="startli">This property returns the height (in pixels) of the rendered image.</p>
</li>
<li><p class="startli"><code>RasterImage RenderedImage { get; }</code></p>
<p class="startli">This is the raster image that resulted from the last rendering action that the renderer has performed.</p>
</li>
<li><p class="startli"><code>DisposableIntPtr RenderedImageData { get; }</code></p>
<p class="startli">This is a disposable pointer that points to the address of the memory holding the data for the <code>RenderedImage</code>. Do not <code>Dispose</code> this manually - it will be automatically disposed once the <code>RenderedImage</code> is collected by the garbage collector and finalized.</p>
</li>
<li><p class="startli"><code>bool InterpolateImage { get; set; } = true</code></p>
<p class="startli">This property determines whether the <code>RenderedImage</code> is interpolated once it is drawn on a <code>Graphics</code> object. If this is <code>false</code>, a "pixelated" effect can be obtained when the image is resized.</p>
</li>
</ul>
<p>The rendering algorithm of the <code>RasterRenderer</code> works with the following steps:</p>
<ol type="1">
<li>Compute shadow list</li>
<li>Cull</li>
<li>Project</li>
<li>Initialise z-buffer</li>
<li>Render</li>
</ol>
<h2><a class="anchor" id="autotoc_md79"></a>
1. Computing the shadow list</h2>
<p>If any of the lights that have been used has its <code>CastsShadow</code> property set to <code>true</code>, the method computes a list of all triangles whose <code>CastsShadow</code> property is also <code>true</code>.</p>
<p>This list of triangles that cast shadows is later used to determine which light sources are not visible from each pixel of a triangle that receives a shadow.</p>
<h2><a class="anchor" id="autotoc_md80"></a>
2. Culling</h2>
<p>In this step, the <code>Camera</code> is asked whether each of the objects in the scene should be culled or not. Non-culled objects are preserved in a list.</p>
<h2><a class="anchor" id="autotoc_md81"></a>
3. Projecting</h2>
<p>In this step, the coordinates of the 2D projection of the triangles in the camera plane are computed using the <code>SetProjection</code> method of the 3D elements. These projections are stored within the 3D element object and are recalled later using the <code>GetProjection</code> method.</p>
<h2><a class="anchor" id="autotoc_md82"></a>
4. Initialising the z-buffer</h2>
<p>Upon its creation, the renderer allocates sufficient memory to hold the z-buffer (which is an array of <code>double</code>s holding the z-depth of the element that caused each pixel to be rendered) and the z-index buffer (which is an array of <code>int</code>s holding the z-index of the element that caused each pixel to be rendered). However, these arrays need to be cleared before each rendering call, otherwise successive renderings would interfere with each other. In this step, the z-buffer is filled with <code>double.MaxValue</code>s and the z-index buffer is filled with <code>int.MinValue</code>s.</p>
<h2><a class="anchor" id="autotoc_md83"></a>
5. Rendering</h2>
<p>In the rendering step, first of all for each element the rectangle that bounds all the pixels that fall within that element is computed.</p>
<p>Then, for each pixel in this rectangle (this step is parallelised), the renderer checks whether the pixel actually falls within the projection of the element.</p>
<ul>
<li>For a <code>Triangle3DElement</code>, this is simply a 2D point-in-triangle test.</li>
<li>For a <code>Point3DElement</code>, the distance of the pixel from the projection of the point is computed, and if this is smaller than or equal to half of the <code>Diameter</code> of the <code>Point3DElement</code>, the pixel is considered to be "inside" the point. If the pixel is outside the point radius, but within 1 pixel, the pixel is considered to be partially inside the point.</li>
<li>For a <code>Line3DElement</code>, the distance of the pixel from the projection of the line is computed.<ul>
<li>If the projection of the pixel on the projection of the line is within the start and end points of the line and the pixel is closer than the line's <code>Thickness</code>, the pixel is considered to be "inside" the line. Like the case of the <code>Point3DElement</code>, if the pixel is outside of the line's <code>Thickness</code>, but still within 1 pixel, it is considered to be partially inside.</li>
<li>If the projection of the pixel on the projection of the line is before the start point or after the and end point, the renderer checks how far it is from the closest endpoint and determines whether the pixel is part of the line cap (if any).</li>
</ul>
</li>
</ul>
<p>For any point that is inside the relevant element, the z-depth is computed. Then, the renderer determines whether the pixel should be rendered in front or behind the current pixel by checking the z-index buffer and the z-buffer.</p>
<ul>
<li>If the z-index buffer at the pixel is less than the z-index of the element, or if they are equal and the z-depth of the pixel is smaller than the z-buffer at the pixel, the pixel should be rendered in front of the current colour at that pixel.</li>
<li>Otherwise, the pixel should be rendered behind the current colour at that pixel. In this case, if the current colour at the pixel is completely opaque (an alpha value of 100%), the new pixel is immediately discarded, and no lighting or shadow computations take place.</li>
</ul>
<p>If the pixel has not been discarded, the new colour for the pixel is computed, trivially for points and lines, and based on the lights and shadows for triangles. Then, if the new pixel is in front of the current pixel, the colours are blended accordingly, and the z-index buffer and the z-buffer are updated to hold the values for the new pixel. If the pixel is instead behind a transparent pixel, the colours are still blended appropriately, but the z-index buffer and the z-buffer are not updated. This can cause artifacts if there are multiple transparent objects one in front of the other (see below).</p>
<p>This process is repeated sequentially for each element in the scene, and then the final image is scaled on a <code>Page</code> of the size defined by the <code>Camera</code> and returned.</p>
<p>Note that if the same renderer is used to render different scenes, this will update <b>all</b> of the pages that have been previously returned by the renderer (this is a side effect of reusing the same <code>RasterImage</code> rather than allocating new memory at every rendering call). Therefore, if you want to keep access to the previously rendered scenes, you should either re-initialise the renderer whenever you render a different scene, or you should e.g. save to disk the rendered scene before rendering the next scene.</p>
<h2><a class="anchor" id="autotoc_md84"></a>
&lt;tt&gt;RasterRenderer&lt;/tt&gt; vs &lt;tt&gt;VectorRenderer&lt;/tt&gt;</h2>
<p>The <code>RasterRenderer</code> prevents the artifacts that arise from using a <code>VectorRenderer</code>, although the result is no longer a vector image. Furthermore, this renderer does not support anti-aliasing, which means that, when viewed at the wrong size, the images can have an ugly effect. The figure below shows a comparison of a detail of a cube rendered with a <code>VectorRenderer</code> (on the left) and with a <code>RasterRenderer</code> (on the right).</p>
<p><img src="images/RasterRendererAliasingExample.svg" alt="" style="pointer-events: none; height: 15em" align="center" class="inline"/></p>
<p>While this effect can be reduced by increasing the resolution (which increases the rendering time and the amount of memory used), it can never be eliminated entirely. Furthermore, this renderer introduces new artifacts due to transparent pixels: since the render does not keep a full stack of the colours behind a transparent pixel, if the elements are processed in the "wrong" order, unexpected results may occur. This can manifest itself first of all as undesirable "edge" effects when <code>Line3DElement</code>s or <code>Point3DElement</code>s are used (because the primitive antialiasing used for them uses semi-transparent pixels):</p>
<p><img src="images/RasterRendererPointArtifact.svg" alt="" style="pointer-events: none; height: 15em" align="center" class="inline"/></p>
<p>In the figure above, the colour of the second rectangle in the back "bleeds" through due to the semi-transparent pixels around the point.</p>
<p>However, the issue is much worse when a transparent element has two or more elements behind:</p>
<p><img src="images/RasterRendererTransparencyArtifact.svg" alt="" style="pointer-events: none; height: 15em" align="center" class="inline"/></p>
<p>In this case, the renderer drew first the solid blue rectangle, then the semi-transparent green rectangle on top of that, but when it was time to render the orange rectangle, the z-buffer at the overlap between the blue rectangle and the green rectangle already had the z-depth of the green rectangle, and the pixel was not transparent because the blue rectangle had already been rendered. This led to the artifact above.</p>
<p>The only way to address these problems would be to rearrange the order in which the elements are added to the scene in the code:</p>
<div class="fragment"><div class="line">// Transparent element is not last: problem</div>
<div class="line"> </div>
<div class="line">// Blue rectangle</div>
<div class="line">scene.AddRange(ObjectFactory.CreateRectangle(new Point3D(-100, -100, 50), new Point3D(100, -100, 50), new Point3D(100, 100, 50), new Point3D(-100, 100, 50), new IMaterial[] { new ColourMaterial(Colour.FromRgb(86, 180, 233)) }));</div>
<div class="line"> </div>
<div class="line">// Green rectangle</div>
<div class="line">scene.AddRange(ObjectFactory.CreateRectangle(new Point3D(-100, -100, -50), new Point3D(100, -100, -50), new Point3D(100, 100, -50), new Point3D(-100, 100, -50), new IMaterial[] { new ColourMaterial(Colour.FromRgba(0, 158, 115, 0.5)) }));</div>
<div class="line"> </div>
<div class="line">// Orange rectangle</div>
<div class="line">scene.AddRange(ObjectFactory.CreateRectangle(new Point3D(-100, -100, -0), new Point3D(100, -100, -0), new Point3D(100, 100, -0), new Point3D(-100, 100, -0), new IMaterial[] { new ColourMaterial(Colour.FromRgb(213, 94, 0)) }));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">//Transparent element is last: problem solved</div>
<div class="line"> </div>
<div class="line">// Blue rectangle</div>
<div class="line">scene.AddRange(ObjectFactory.CreateRectangle(new Point3D(-100, -100, 50), new Point3D(100, -100, 50), new Point3D(100, 100, 50), new Point3D(-100, 100, 50), new IMaterial[] { new ColourMaterial(Colour.FromRgb(86, 180, 233)) }));</div>
<div class="line"> </div>
<div class="line">// Orange rectangle</div>
<div class="line">scene.AddRange(ObjectFactory.CreateRectangle(new Point3D(-100, -100, -0), new Point3D(100, -100, -0), new Point3D(100, 100, -0), new Point3D(-100, 100, -0), new IMaterial[] { new ColourMaterial(Colour.FromRgb(213, 94, 0)) }));</div>
<div class="line"> </div>
<div class="line">// Green rectangle</div>
<div class="line">scene.AddRange(ObjectFactory.CreateRectangle(new Point3D(-100, -100, -50), new Point3D(100, -100, -50), new Point3D(100, 100, -50), new Point3D(-100, 100, -50), new IMaterial[] { new ColourMaterial(Colour.FromRgba(0, 158, 115, 0.5)) }));</div>
</div><!-- fragment --><p><img src="images/RasterRendererTransparencyArtifactSolved.svg" alt="" style="pointer-events: none; height: 15em" align="center" class="inline"/></p>
<p>However, this is finicky and should not be relied upon (the order of the elements in the scene, or even the fact that there <em>is</em> an order to them at all, is an implementation detail). In situations like these, it would be best to use another renderer. For comparison, here is how the images look like when rendered using the <code>VectorRenderer</code>:</p>
<p><img src="images/RasterRendererTransparencyArtifactVectorRenderer.svg" alt="" style="pointer-events: none; height: 15em" align="center" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md85"></a>
Tips for using the &lt;tt&gt;RasterRenderer&lt;/tt&gt;</h2>
<ul>
<li>Use a high rendering resolution (maybe use a lower resolution during development, and then change to a higher resolution once you are satisfied with the arrangement of the objects in the scene).</li>
<li>Avoid <code>Point3DElement</code>s and <code>Line3DElement</code>s. If you need to use them, add them to the scene after all other elements have been added.</li>
<li>Avoid transparent elements. If you need to use them, add them to the scene after all other elements have been added.</li>
<li>In most cases, using the <code>RaycastingRenderer</code> (see below) will produce better results than the <code>RasterRenderer</code>, though its performance can be worse depending on the scene, the resolutions, and the number of available processors.</li>
</ul>
<h1><a class="anchor" id="autotoc_md86"></a>
The &lt;tt&gt;RaycastingRenderer&lt;/tt&gt; class</h1>
<p>The <code>RaycastingRenderer</code> uses yet a different algorithm, which aims at solving the issues of the <code>RasterRenderer</code>. Working on a pixel-by-pixel basis, this renderer casts a ray from the camera eye through the coordinates of the pixel on the camera plane, and determines which objects the ray hits. It then sorts these objects based on their distance from the camera, and computes the colour of the pixel starting from the closest object and overlaying the colors one over the other until the pixel is completely opaque (or it reaches the last object).</p>
<p>This solves the issue with transparent objects lying one over the other, and also makes it trivial (though computationally expensive) to perform anti-aliasing. In a non-antialiased image, a single ray is cast for each pixel, aimed at the centre of the pixel. If 4X bilinear antialiasing (the only kind of antialiasing currently implemented) is enabled, four rays are instead cast for each pixel and the colour of the pixel is computed as the average of the colours obtained through each ray. In the figure below, each square represents a single pixel; the image on the left shows the point in the pixel through which the ray is cast when antialiasing is disabled, while the image on the right shows the points that are used when 4X antialiasing is enabled.</p>
<p><img src="images/AntiAliasingSamplePositions.svg" alt="" style="pointer-events: none; height: 15em" align="center" class="inline"/></p>
<p>The figure below shows how antialiasing can be used to reduce the jagged-edge effect. The image on the left is rendered without antialiasing (and is very similar to the <code>VectorRenderer</code> example above), while the image on the right has 4X bilinear antialiasing enabled.</p>
<p><img src="images/RaycastingRendererAntiAliasing.svg" alt="" style="pointer-events: none; height: 15em" align="center" class="inline"/></p>
<p>The main drawback of enabling antialiasing is that, since each pixel needs to be sampled four times, it causes a 400% increase in rendering time.</p>
<p>The constructor for this class requires two <code>int</code> parameters, which represent the width and height (in pixels) of the rendered image. Note that the <code>Page</code> returned by the <code>Render</code> method will always have the same size as the camera's <code>Size</code> property.</p>
<p>This class defines the following public members:</p>
<ul>
<li><p class="startli"><code>int RenderWidth { get; }</code></p>
<p class="startli">This property returns the width (in pixels) of the rendered image.</p>
</li>
<li><p class="startli"><code>int RenderHeight { get; }</code></p>
<p class="startli">This property returns the height (in pixels) of the rendered image.</p>
</li>
<li><p class="startli"><code>RasterImage RenderedImage { get; }</code></p>
<p class="startli">This is the raster image that resulted from the last rendering action that the renderer has performed.</p>
</li>
<li><p class="startli"><code>DisposableIntPtr RenderedImageData { get; }</code></p>
<p class="startli">This is a disposable pointer that points to the address of the memory holding the data for the <code>RenderedImage</code>. Do not <code>Dispose</code> this manually - it will be automatically disposed once the <code>RenderedImage</code> is collected by the garbage collector and finalized.</p>
</li>
<li><p class="startli"><code>bool InterpolateImage { get; set; } = true</code></p>
<p class="startli">This property determines whether the <code>RenderedImage</code> is interpolated once it is drawn on a <code>Graphics</code> object. If this is <code>false</code>, a "pixelated" effect can be obtained when the image is resized.</p>
</li>
<li><p class="startli"><code>AntiAliasings AntiAliasing { get; set; }</code></p>
<p class="startli">This property determines whether anti-aliasing is used for the rendered image. The <code>AntiAliasings</code> enum is defined within this class; it can have two values: <code>AntiAliasings.None</code> (which disables antialiasing) and <code>AntiAliasings.Bilinear4X</code> (which causes each pixel to be sampled four times).</p>
</li>
<li><p class="startli"><code>event EventHandler&lt;RaycastingRendererProgressEventArgs&gt; Progress</code></p>
<p class="startli">This event will be called up to 1000 times during the rendering process; the <code>RaycastingRendererProgressEventArgs</code> has a <code>Progress</code> property whose value will be between <code>0</code> (at the start of the rendering) and <code>1</code> (once every pixel in the image has been rendered), representing an <em>approximate</em> indication of the progress of the rendering process.</p>
</li>
</ul>
<p>The rendering algorithm of the <code>RaycastingRenderer</code> works with the following steps:</p>
<ol type="1">
<li>Obtain cameras</li>
<li>Compute shadow list</li>
<li>Cull</li>
<li>Project</li>
<li>Render</li>
</ol>
<h2><a class="anchor" id="autotoc_md87"></a>
1. Obtaining cameras</h2>
<p>If the camera that is being used implements the <code>IBlurrableCamera</code> interface, the <code>GetCameras</code> method of the camera is invoked to obtain the cameras that will be used to render and blur the scene.</p>
<h2><a class="anchor" id="autotoc_md88"></a>
2. Computing the shadow list</h2>
<p>If any of the lights that have been used has its <code>CastsShadow</code> property set to <code>true</code>, the method computes a list of all triangles whose <code>CastsShadow</code> property is also <code>true</code>.</p>
<p>This list of triangles that cast shadows is later used to determine which light sources are not visible from each pixel of a triangle that receives a shadow.</p>
<h2><a class="anchor" id="autotoc_md89"></a>
3. Culling</h2>
<p>In this step, each <code>Camera</code> is asked whether each of the objects in the scene should be culled or not. Non-culled objects are preserved in a list. One list is kept for each of the cameras from step 1.</p>
<h2><a class="anchor" id="autotoc_md90"></a>
4. Projecting</h2>
<p>This step is only performed if there is only one camera (i.e. no blurring is to be performed). Here, the coordinates of the 2D projection of the triangles in the camera plane are computed using the <code>SetProjection</code> method of the 3D elements. These projections are stored within the 3D element object and are recalled later using the <code>GetProjection</code> method.</p>
<p>If more than one camera has been obtained in step 1, this projection step is not performed, and instead the projections are computed during the rendering step. This is one of the reasons why using blurring can increase the rendering time.</p>
<h2><a class="anchor" id="autotoc_md91"></a>
5. Rendering</h2>
<p>During rendering, for each pixel and for each camera, the renderer sends a ray starting at the camera eye and passing through the centre of the pixel (if antialising is enabled, four rays are cast for each camera). The ray is compared with all non-culled elements in the scene, in order to determine which elements intersect it. These are then sorted, based on the distance between the element and the camera (and the z-index).</p>
<p>Starting from the element closest to the camera, the renderer determines the colour of the pixel due to that element. If the colour is completely opaque, the rendering of the pixel is complete. Otherwise, the colour of the next element is determined, and so on until the pixel is completely opaque or the last element in the intersection list has been reached.</p>
<p>This process is parallelised over the pixels using <code>Parallel.For</code>, which should use as many CPU cores as are available.</p>
<h2><a class="anchor" id="autotoc_md92"></a>
&lt;tt&gt;RaycastingRenderer&lt;/tt&gt; vs &lt;tt&gt;RasterRenderer&lt;/tt&gt; vs &lt;tt&gt;VectorRenderer&lt;/tt&gt;</h2>
<p>Unlike the other renderers, the <code>RaycastingRenderer</code> should not cause any particular artifacts during rendering. It is therefore suitable to obtain a "reference" rendering, which can then e.g. be compared to rendering using the <code>VectorRenderer</code>, to determine whether there are any perceivable differences.</p>
<p>The main disadvantage of this renderer against the <code>RasterRenderer</code> and <code>VectorRenderer</code> is the slower performance. While anti-aliasing makes images obtained with a <code>RaycastingRenderer</code> still bearable even when magnified or reduced, they are still raster images; therefore, the vector images obtained using the <code>VectorRenderer</code> may be more suitable (depending on the purpose) when the final rendering resolution is not known.</p>
<h2><a class="anchor" id="autotoc_md93"></a>
Tips for using the &lt;tt&gt;RaycastingRenderer&lt;/tt&gt;</h2>
<ul>
<li>Develop scenes using a lower rendering resolution and disabling effects that cause each pixel to be sampled multiple times (e.g. anti-aliasing, focus blur, soft shadows...). Once you are satisfied with the position of the objects, camera and lights, increase the resolution and activate the effects.</li>
<li>Alternatively, you can also preview the scene using another renderer, and then switch to the <code>RaycastingRenderer</code> for the final rendering.</li>
<li>Resampling effects have a cumulative effect on rendering time: for example, if 4X anti-aliasing is used together with focus blurring with 32 samples and soft shadows also with 32 shadow sampling points, each pixel will be sampled 32 * 4 = 128 times, and each of these will involve 32 shadow computations, for a total of 131'072 shadow computations per pixel!</li>
</ul>
<h1><a class="anchor" id="autotoc_md94"></a>
How to choose the best renderer</h1>
<ul>
<li>If you need vector graphics output, you should use the <code>VectorRenderer</code>.</li>
<li>Otherwise, you should use the <code>RaycastingRenderer</code>.</li>
<li>If you find that in your case the <code>RasterRenderer</code> performs better than the <code>RaycastingRenderer</code>, and the reduced graphics quality is not a problem, you can use the <code>RasterRenderer</code>. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
